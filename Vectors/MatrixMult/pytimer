#!/usr/bin/python
""" This script takes an integer argument, which is then passed into 
        the benchmarking scripts. Each script attempts to do the same thing:
    1. generate a square random matrix comprised of two random vectors multiplied together
    2. multiply the first random vector with the matrix (perform the dot product)
    3. print the resulting vector to standard output (console)
"""
import sys, time, os, subprocess

matrixSize = sys.argv[1] # pass in an integer to this script

silent = " 2>&1 > /dev/null" # redirect standard output to trash
jtest  = "./bin/jnothing.ijs"
jreal  = "./bin/jexe.ijs"
ctest  = "./bin/cnothing.out"
creal  = "./bin/cexe.out"

def timer(filename):
    """ Measure the time it takes to invoke the given command
    using a shell subprocess. """
    strCmd = filename + silent
    start = end = 0
    start = time.time()
    myProcess = subprocess.Popen(strCmd, shell=True)
    myProcess.wait()
    end = time.time()
    return end - start

def av(filename, test, iters = 10):
    avg = 0
    for i in range(iters):
        if (test):
            avg += timer(filename)
        else:
            avg += timer(filename + " " + matrixSize)
    return avg / iters

def winner(a1, n1, a2, n2):
    output = "Results:\n"
    output += n1 + ": " + str(a1) + "\n"
    output += n2 + ": " + str(a2) + "\n"
    if (a1 == a2):
        output += "tie"
    if (a1 < a2):
        output += n1 + " was " + str(a2 / a1) + " times faster."
    if (a1 > a2):
        output += n2 + " was " + str(a1 / a2) + " times faster."
    return output

# use these two to subtract the estimated time required just run the executable or script
#see = av(creal, False) - av(ctest, True)
#jay = av(jreal, False) - av(jtest, True)

# OR, use these instead to get the average time only
#see = av(creal, False, 10)
#jay = av(jreal, False, 10)

# OR, just the results of a single run, no averaging
see = timer(creal + " " + matrixSize)
jay = timer(jreal + " " + matrixSize)

print winner(see, "C++", jay, "J")

